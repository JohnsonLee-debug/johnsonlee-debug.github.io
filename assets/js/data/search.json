[ { "title": "泛型在Go中的应用", "url": "/posts/go-generics/", "categories": "Go", "tags": "Generics, Error Handling", "date": "2022-03-22 20:08:00 +0800", "snippet": "Go1.18正式发布，从此Go算是正式有了泛型，本文来探讨Go泛型的几种应用场景。类型安全的函数式接口在Go语言里，函数是一等公民，这意味着你可以进行一定程度的函数式编程，但是因为Go拉胯的类型系统以及Lambda表达式的缺位，Go做起函数式编程来总是不太舒服，现在有了参数化类型以后map，fold，filter等函数总算是能舒服些了。接下来看看如何利用泛型实现出类型安全的Map， Filter， Foldl，Foldr。实现从这几个函数的类型签名入手，然后按语义进行翻译就是了： 这里类型签名采用我偏爱的Haskell的类型签名（同时混合使用了Go的类型），个人认为这种记法的好处在于分离了identifier和type signature，便于一眼看出函数的类型以及进行类型的运算；这种记法里的-&amp;gt;可以理解为一个映射 Map :: (A -&amp;gt; B) -&amp;gt; []A -&amp;gt; []B 对应的Go实现: func Map[A, B any](f func(A) B, l []A) []B { res := make([]B, len(l)) for i, e := range l { res[i] = f(e) } return res} Filter :: (A -&amp;gt; bool) -&amp;gt; []A -&amp;gt; []A 对应的Go实现: func Filter[A any](f func(A) bool, l []A) []A { res := make([]A, 0, len(l)) for _, e := range l { if f(e) { res = append(res, e) } } return res} Foldl :: (B -&amp;gt; A -&amp;gt; B) -&amp;gt; B -&amp;gt; []A -&amp;gt; B 对应的Go实现 func Foldl[A, B any](f func(B, A) B, b B, l []A) B { res := b for _, e := range l { res = f(res, e) } return res} Foldr :: (A -&amp;gt; B -&amp;gt; B) -&amp;gt; B -&amp;gt; []A -&amp;gt; B 对应的Go实现 func Foldr[A, B any](f func(A, B) B, b B, l []A) B { res := b for i := len(l) - 1; i &amp;gt;= 0; i-- { res = f(l[i], res) } return res} ForEach :: (A -&amp;gt; Unit) -&amp;gt; []A -&amp;gt; Unit 这里Unit用来表示无返回 对应的Go实现 func ForEach[A any](f func(A), l []A) { for _, e := range l { f(e) }}借助上面这些基本函数可以实现出:concat，concatMapfunc Concat[A any](l [][]A) []A { return Foldl(func(a []A, b []A) []A { return append(a, b...) }, []A{}, l)}func ConcatMap[A, B any](f func(A) []B, l []A) []B { return Concat(Map(f, l))}应用比较常见的简单应用就不说了，例如Web开发中可以利用Map方便地进行Vo,Dto,Entity之间的转换。这里给几个比较fancy的例子： 全排列函数(这里假设列表里没有重复元素了，为了Remove实现方便一点)func Remove(x int, l []int) []int { return Filter(func(y int) bool { return x != y }, l)}func Permutations(s []int) [][]int {// 如果s是个空集合，那么其全排列为一个包含空集合的集合，即{Ф} if len(s) == 0 { return [][]int{[]int{}} }/* 这个ConcatMap是精髓，先看ConcatMap的对象，就是s，所以对每个元素都会执行第一个函数参数 * 第一个函数的意思是：接受元素x，然后把集合s中的x去除以后对剩下的部分进行全排列， * 然后向得到的全排列集合里的每个切片的最后上插一个x * 如此一来就得到了以x为尾其余元素的一个全排列为头的集合的集合； * 对s中的每个元素都应用这个函数然后再拼接不就得到了所有元素的全排列 * 当然这个实现是满出翔并且有bug的 */ return ConcatMap(func(x int) [][]int { return Map(func(p []int) []int { return append(p, x) }, Permutations(Remove(x, s))) }, s)} 求解八皇后func abs(x int) int { if x &amp;lt; 0 { return -x } return x}func safe(k int, positions []int) bool { for i, p := range positions { if p == k || abs(p-k) == i+1 { return false } } return true}func sequence(a, b int) []int { if a &amp;gt; b { return []int{} } result := make([]int, b-a+1) for i := range result { result[i] = a + i } return result}func positions(k, n int) [][]int {//positions: 尝试在大小为n的棋盘的第k行放棋子 if k == 0 { return [][]int{[]int{}} } conf := positions(k-1, n) /* * 稍微解释一下这坨怪物，其实懂了以后就明白这是个非常简洁的回溯 * 首先看ConcatMap的对象，sequence(1, n)，其实就是对于从1..n这n个位置，循环使用第一个函数 * 可以展开成对应的for循环 * 然后Map的效果是在对头上插上p * Filter过滤出那些在p上放置棋子仍然安全的情况(这样就会边搜索边剪枝了) */ return ConcatMap(func(p int) [][]int { return Map(func(ps []int) []int { return append([]int{p}, ps...) }, Filter(func(ps []int) bool { return safe(p, ps) }, conf)) }, sequence(1, n))}func Queen(boardSize int) [][]int { return positions(boardSize, boardSize)}与Go泛型相关内容，计划下一篇更新迭代器模式" }, { "title": "词法分析之NFA, DFA, Min-DFA与RE, RG", "url": "/posts/FSA_and_RE/", "categories": "编译原理, 词法分析", "tags": "自动机理论, Finite State Automata", "date": "2022-03-02 23:52:00 +0800", "snippet": " Computation with automata.Glossary NFA: Non-Deterministic Finite Automata 非确定性的有限状态自动机 对于NFA的非确定, 有两种有趣的解释 在需要做出不确定选择的时候, NFA会复制自己并执行所有的操作, 如果最终有任何一台自动机到达了接收状态, 那么NFA接收这个输入 在需要做出不确定选择的时候, NFA的选择总是正确, 也就是说, 只要这个串是能被接收的, 那NFA一定能选对 DFA: Deterministic Finite Automata 确定性的有限状态自动机 Min-DFA: Minimal Deterministic Finite Automata 最小的DFA RE: Regular Expression 正则表达式 RG: Regular Grammar 正则文法NFA,DFA,Min-DFA,RE的关系一般地，认为NFA, DFA, Min-DFA, RE的关系如下graph LRA[NFA]B[DFA]D[RE]E([code for a scanner])A--Subset Construction--&amp;gt;B--Kleene&#39;s Construction--&amp;gt;D--Thompson&#39;s Construction--&amp;gt;AB--DFA Minimization--&amp;gt;BA--&amp;gt;ED--Direct method--&amp;gt;BDFA Minimization有两种算法: Brzozowski, Hopcroft.RE to NFA: Thompson Construction先看正则表达式的结构, 这里就不那么形式化了, 用Haskell的语法写了=_=data RegExp = Symbol Char -- Basic Character a | Concat RegExp RegExp -- Concatenation ab | Union RegExp RegExp -- Union a+b | Star RegExp -- Kleene star a* 当RegExp是Symbol a时 stateDiagram-v2 direction LR s0 s1 [*]--&amp;gt;s0 s0--&amp;gt;s1:a s1--&amp;gt;[*] 当RegExp是Concat e1 e2时 stateDiagram-v2 direction LR %% e1--&amp;gt;e2:ε s1--&amp;gt;s3:ε state e1{ direction LR [*]--&amp;gt;s0 s0--&amp;gt;s1 } state e2{ direction LR s3--&amp;gt;s4 s4--&amp;gt;[*] } 或者 stateDiagram-v2 direction LR s1:公共结点 s0--&amp;gt;s1 s1--&amp;gt;s2 state e1{ direction LR [*]--&amp;gt;s0 } state e2{ direction LR s2--&amp;gt;[*] } 当RegExp是Union e1 e2时 stateDiagram-v2 direction LR [*]--&amp;gt;s0 s0--&amp;gt;s1:ε s0--&amp;gt;s3:ε s2--&amp;gt;s5:ε s4--&amp;gt;s5:ε s5--&amp;gt;[*] state e1{ direction LR s1--&amp;gt;s2 } state e2{ direction LR s3--&amp;gt;s4 } 当RegExp是Star e时 stateDiagram-v2 direction LR [*]--&amp;gt;s0 s0--&amp;gt;s1:ε s2--&amp;gt;s3:ε s3--&amp;gt;[*] s0--&amp;gt;s3:ε state e{ direction LR s1--&amp;gt;s2 s2--&amp;gt;s1:ε } 做题的时候一定不要图省事, 省略某些步骤; 严格按照这四个pattern来, 会让你避免很多麻烦NFA to DFA: 子集构造法子集构造法有两个重要的函数 $\\text{Move}(s_i, a)$, 返回从状态$s_i$接收输入$a$能到达的状态集合 $\\text{FollowEpsilon}(s_i)$, 返回从状态$s_i$接收$\\epsilon$能到达的状态集合, 包括$s_i$本身和经过多次空转移到达的状态用自然语言描述这个算法就是: 从NFA的起始状态$n_0$构造出DFA的起始状态$d_0$ $d_0 = \\text{FollowEpsilon}({n_0})$ 令$D = {d_0}$ 对所有$\\alpha\\in \\Sigma$, 计算$\\text{FollowEpsilon}(\\text{Move}(d_0, \\alpha))$ 如果这一步算出了新状态, 将其加入$D$ 遍历$D$, 对每个状态计算$\\text{FollowEpsilon}(\\text{Move}(d_0, \\alpha))$, 直到没有新状态产生为止 子集构造法也涉及到不动点问题. 用伪代码则是:\\[\\begin{align*}&amp;amp;d_0 \\leftarrow \\text{FollowEpsilon}({n_0}) \\\\&amp;amp;D \\leftarrow \\{d_0\\} \\\\&amp;amp;W \\leftarrow \\{d_0\\} \\\\&amp;amp;\\text{while }(W \\ne \\emptyset)\\ \\{ \\\\ &amp;amp;\\quad\\text{从}W\\text{里随便选择并删除一个元素}s\\\\ &amp;amp;\\quad\\text{for each } \\alpha \\in \\Sigma\\ \\{ \\\\ &amp;amp;\\quad\\quad t \\leftarrow \\text{FollowEpsilon}(\\text{Move}(s, a))\\\\ &amp;amp;\\quad\\quad T[s, \\alpha]\\leftarrow t \\\\ &amp;amp;\\quad\\quad \\text{if }(t \\notin D) \\text{ then \\{}\\\\ &amp;amp;\\quad\\quad\\quad \\text{向}D\\text{里添加}t\\\\ &amp;amp;\\quad\\quad\\quad \\text{向}W\\text{里添加}t\\\\ &amp;amp;\\quad\\quad\\}\\\\ &amp;amp;\\quad\\}\\\\&amp;amp;\\}\\end{align*}\\]容易知道, 子集构造法本质上就是合并了不同状态的相同前缀, 因为在DFA里的每个状态都是由NFA里的一个状态$s_i$经过空串或一个字母$\\alpha$迁移过来的.DFA to Minimal DFA状态机里可能存在冗余的状态, 也是说有多个状态无法找到一个输入串区分它们, 形式化的描述是:\\[s_i\\text{和}s_j\\text{是等价状态} \\Leftrightarrow \\forall c\\in \\Sigma, T(s_i, c) = T(s_j, c) \\land \\text{Path}(s_0, s_i) = \\text{Path}(s_0, s_j)\\]Brzozowski’s algorithm核心想法: 既然子集构造法能合并相同前缀的状态, 那我能不能再利用子集构造法合并冗余状态呢? 冗余就是那些前缀相同和后缀相同的状态, 那么我把状态机翻过来做一次子集构造法不就能合并后缀, 再翻过来做一次子集构造法不就把前缀也合并了.基于上面这个想法, Brzozowski设计了如下的算法进行DFA的最小化. 将NFA翻转过来, 得到NFA’ 对NFA’执行子集构造法得到DFA’, 此时完成了后缀合并, 但这个时候自动机是反的 将DFA’翻转过来得到NFA’’, 对NFA’‘进行子集构造法, 就完成了前缀的合并, 并且自动机也翻回正向的了翻转自动机的方法: 将原自动机的边翻转, 原自动机的起始状态成为终止状态, 原自动机的终止状态成为起始状态, 如果原自动机有多个终止状态那就新增一个状态$s_e$, 所有原终止状态通过$\\epsilon$转移到$s_e$即可继续翻转.Hopcroft’s algorithm核心想法: Hopcroft的想法更直接, 基本的idea就是: 最小化DFA不就是把等价的状态划分到一起, 那不就是找原状态机里的一个划分, 把等价的状态放到一起, 划分的每个组内的状态相互不可区分, 然后用这个划分组成新的自动机.我们希望这个划分应该有什么性质才能保证DFA是最小的呢? 假定最后的划分是$P={p_0, p_1, p_2, \\dots p_n}$, $P$应该有这样的性质: 如果$d_i, d_j \\in p_s$并且如果有$c$使得$d_i\\to d_x, d_j\\to d_y$, 那么$d_x, d_y\\in p_t$ 如果$d_i, d_j \\in p_s$并且$d_i\\in F$, 那么$d_j\\in F$($F$是接收状态集合)具体的运算过程: 先乐观地将所有状态划分为两个组: 接收状态组和其他状态组, (这是因为我们希望最终得到的划分组数最少) 从当前划分中任意选取一个状态组, 检查是否存在一个字母$c$使得组内的状态迁移到不同的组内, 如果存在那就按照这些迁移将该组进行划分, 使得划分后的一个状态组内的每个状态在字母$c$下都迁移到同一个组内. 重复执行该步骤直到无法根据某个字母对任何一个组进行分割为止.伪代码:\\[\\begin{align*}&amp;amp;worklist \\leftarrow \\{F, \\{D-F\\}\\} \\\\&amp;amp;partition \\leftarrow \\{F, \\{D-F\\}\\} \\\\&amp;amp;\\text{while }(worklist \\ne \\emptyset) \\text{ \\{} \\\\&amp;amp;\\quad \\text{从}worklist\\text{中选取并移除一个状态组}S \\\\&amp;amp;\\quad \\text{for each } \\alpha \\in \\Sigma \\text{ \\{} \\\\&amp;amp;\\quad \\quad image \\leftarrow \\{x \\vert \\delta (x, \\alpha) \\in S \\} \\\\&amp;amp;\\quad \\quad \\text{for each } q \\in partition \\text{ that has a state in image \\{} \\\\&amp;amp;\\quad \\quad \\quad q_1 \\leftarrow q \\cap image \\\\&amp;amp;\\quad \\quad \\quad q_2 \\leftarrow q - q_1 \\\\&amp;amp;\\quad \\quad \\quad \\text{if } q_2 \\ne \\emptyset \\text{ \\{} \\\\&amp;amp;\\quad \\quad \\quad \\quad \\text{从}partition\\text{中移除}q \\\\&amp;amp;\\quad \\quad \\quad \\quad partition \\leftarrow partition \\cup q_1 \\cup q_2 \\\\&amp;amp;\\quad \\quad \\quad \\quad \\text{if } q \\in worklist \\text{ \\{} \\\\&amp;amp;\\quad \\quad \\quad \\quad \\quad \\text{从}worklist\\text{中移除}q \\\\&amp;amp;\\quad \\quad \\quad \\quad \\quad worklist \\leftarrow worklist \\cup q_1 \\cup q_2 \\\\&amp;amp;\\quad \\quad \\quad \\quad \\text{else } \\text{if } \\vert q_1 \\vert \\le \\vert q_2 \\vert \\text{ \\{} \\\\&amp;amp;\\quad \\quad \\quad \\quad \\quad worklist \\leftarrow worklist \\cup q_1 \\\\&amp;amp;\\quad \\quad \\quad \\quad \\text{else } \\\\&amp;amp;\\quad \\quad \\quad \\quad \\quad worklist \\leftarrow worklist \\cup q_2 \\\\&amp;amp;\\quad \\quad \\quad \\quad \\} \\\\&amp;amp;\\quad \\quad \\quad \\quad \\text{if } s = q \\text{ \\{} \\\\&amp;amp;\\quad \\quad \\quad \\quad \\quad break; \\\\&amp;amp;\\quad \\quad \\quad \\quad \\} \\\\&amp;amp;\\quad \\quad \\quad \\} \\\\&amp;amp;\\quad \\quad \\} \\\\&amp;amp;\\quad \\} \\\\&amp;amp;\\} \\\\\\end{align*}\\]DFA to RE: Kleene’s construction定理: 如果$L=L(A)$是某DFA $A$的语言, 那么存在正则表达式$R$满足$L=L(R)$进行转换的基本idea: $R_{ij} = R_{ij}^{不经过k}+R_{ik}^{不经过k}(R_{kk}^{不经过k})^*R_{kj}^{不经过k}$ 定理及证明: 对DFA $A$的状态编号, 令1为开始状态, 即\\[A=(\\{1, 2, \\dots, n\\}, \\Sigma, \\delta, 1, F)\\] 设正则表达式$R_{ik}^{(k)}$表示从$i$到$j$但中间节点标号不超过$k$全部路径的字符串集合\\[R_{ij}^{(k)} = \\{ x | \\hat \\delta(i, x) = j, x经过的状态除两端外标号不超过k\\}\\] 那么与$A=({1, 2, \\dots, n}, \\Sigma, \\delta, 1, F)$等价的正则表达式为\\[\\bigcup_{j\\in F}R_{1j}^{(n)}\\] 且递归式为\\[R_{ij}^{(k)} = R_{ij}^{(k-1)} + R_{ik}^{(k-1)}(R_{kk}^{(k-1)})^*R_{kj}^{(k-1)}\\]\\[R_ij^{(0)} = \\begin{cases} \\{\\alpha | \\delta(q_i, \\alpha) = q_j\\} &amp;amp; i\\ne j \\\\ \\{\\alpha | \\delta(q_i, \\alpha) = q_j\\} \\cup \\{\\epsilon\\} &amp;amp; i = j \\\\ \\end{cases}\\] Base case: 当$i\\ne j, k = 0$时, 即$i$到$j$没经过任何中间结点 没有$i$到$j$的状态转移 graph LRi((i))j((j)) $R_{ij}^{(0)}=\\emptyset$ 有一个$i$到$j$的状态转移 graph LRi((i))j((j))i--a--&amp;gt;j $R_{ij}^{(0)}=a$ 有多个$i$到$j$的状态转移 graph LRi((i))j((j))i--a--&amp;gt;ji--b--&amp;gt;ji--c--&amp;gt;j $R_{ij}^{(0)}=a+b+c$ 当$i = j, k = 0$时, 即从$i$到自身没经过任何中间结点 状态$i$没有到自己的转移 graph LRi((i)) $R_{ii}^{(0)} = \\varepsilon$ 状态$i$有一个到自身的转移 graph LRi((i))i--a--&amp;gt;i $R_{ii}^{(0)} = a + \\varepsilon$ 状态$i$有多个到自身的转移 graph LRi((i))i--a--&amp;gt;ii--b--&amp;gt;ii--c--&amp;gt;i $R_{ii}^{(0)} = a + b + c \\varepsilon$ " }, { "title": "常用网站分类收藏", "url": "/posts/website_archive/", "categories": "网站分类收藏", "tags": "", "date": "2022-02-26 00:00:00 +0800", "snippet": " Frequently use website资源类 Google Scholar IEEE Xplore ACM Digital Library IACR’s ePrint archive DBLP arXiv CiteSeerX JSTOR SpringerLink Semantic Scholar Libgen SciHub大牛博客 包云岗的博客 美团技术团队 Keep Coding Tech Explorer, 数据库, LinuxC 凝神长老 阮一峰 JR’s Blog Mthli JYY的WIKI 玄简君 Kaito, 中间件, 分布式系统的讲解非常不错Go语言 Go设计模式与Web开发等 Go Wiki Go语言高性能编程 菜刚(Golang系列)Java语言 BaeldungWSL WSL设置静态IP WSL里使用nvim如何共享剪贴板问题公开课 名校公开课程评价网 南大SICP 南大ICS PA CS4160 形式化验证 COMS W3157 Programming Language and Translators 南大静态分析 CMU静态分析 CS144 Introduction to Computer Networking JYY蒋神OS 国科大陈立前老师程序分析 熊英飞软件分析技术视频 熊英飞软件分析技术Slides 梁红瑾程序设计语言的形式语义 Stanford CS242 CS3520 Utah Cornell CS3110 MIT 6.824免费书籍 HTDP Crafting Interpreter 一份不太简短的LATEX2e介绍 OCaml Programming: Correct + Efficient + Beautiful Real World OCaml How To Ask Question Operating System: Three Easy Pieces Jeff Erickson的Algorithms How to Read a Paper工具网站 GodBolt 数据神厨 PasteBin 代码查重，MOSS 正则表达式转非确定性有穷自动机 正则表达式铁道图 自动机模拟器 Regex Debugger Overleaf 在线LaTex编辑器 Tables Generator 表格生成器 QuillBot Paraphrase 工具 Detexify 识别手写符号输出LaTex指令 Connected Papers 论文关联可视化 Academic Phrase Bank 一些模板句 doi2bib 把DOI转成BibTex Linggle 词汇搭配分析 Shapecatcher Unicode手写识别 Try It Online 各种编程语言在线运行MISC 如何在Markdown里使用PlantUML画图 Tmux 使用教程 一年成为Emacs高手 Mirage OS(Unikernel) JYY开发的代码查重吉他谱 夕凪" }, { "title": "通用的Memorization方法", "url": "/posts/memorize/", "categories": "SICP", "tags": "python, lisp", "date": "2021-04-23 16:58:00 +0800", "snippet": " 最近看到了一个scheme实现的通用记忆化方法，但其代码晦涩难懂，整理了一份python版本，发现远比lisp简单明了，遂写一篇博客保留之。1. Intro记忆法(Memorization)，或称表格法(tabulation)是一种常用的缓存技术，采用这种技术的函数将前面已经算出的一些值记录在一个局部的字典里，这种手段能够大大加快一些函数的效率。采用记忆法的过程维护着一个字典，其中保存着前面已经做过的调用求出的值，以产生这些值的对应参数作为Key。当这种过程被调用时，它首先检查有关的字典，看看相应的值是否已经在那里，如果找到了，就直接返回这个值; 否则就以正常的方式计算出相应的值，并将这个值保存到表格里。举一个经典的例子:memo = {0: 0, 1: 1}# 不带记忆的版本def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n - 1) + fib(n - 2)## fib(30) time elapsed: 0.2773573199999999# 带记忆的版本def fib_memo(n): if n in memo: return memo[n] else: memo[n] = fib(n - 1) + fib(n - 2) return memo[n]## fib_memo(30) time elapsed: 4.91160000000157e-05容易知道不带记忆的函数计算较带记忆的函数慢很多。记忆法很不错，但是采用上述记忆法带来的缺点有: 需要修改函数的具体实现 要引入一个全局变量进行记忆 记忆的方法不通用2. Generalize针对以上三个缺点，我们来逐一解决。2.1 消除全局变量还是以斐波那契为例，memo的目的是记录函数运行的结果，要做到这一点不需要使用全局变量，只需要让我们的函数带上自由变量即可。def get_fib(): memo = {0: 0, 1: 1} def inner(n): if n in memo: return memo[n] else: memo[n] = inner(n - 1) + inner(n - 2) return memo[n] return innerfib = get_fib()## fib(30) time elapsed: 4.8156000000076915e-052.2 让记忆方法通用通过前面的修改，我们消除了全局变量。观察到inner中对memo进行了修改的只有一行memo[n] = inner(n - 1) + inner(n - 2)，这里可以抽象成为一个计算过程f，f可作为参数传入。根据这个idea我们得到了以下代码：def memorize(f): memo = {} def inner(n): if n not in memo: memo[n] = f(n) return memo[n] return inner fib_memo_lambda = memorize(lambda x: 0 if x == 0 else 1 if x == 1 else fib_memo_lambda(x - 1)+fib_memo_lambda(x - 2))## fib_memo_lambda(30) time elapsed: 9.787600000010777e-05def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n - 1) + fib(n - 2)这样我们把记忆的过程抽象出来了，memorize就成为了一个通用的记忆方法。但是这个实现我们还是需要修改fib原来的实现，并且fib_memo这种利用lambda表达式的方法令人费解（It is actually a little tricky,具体tricky在哪儿，请看思考题），能不能再优化一下？ 思考题: 把fib_memo直接定义为memorize(fib)是否能提高计算效率？为什么？2.3 无需改动原函数实现记忆我们只需要利用Python中的装饰器(Decorator),就能达到不改动函数实现而能提升计算效率的效果。def memorize(f): memo = {} def inner(x): if x not in memo: memo[x] = f(x) return memo[x] return inner@memorizedef fib_memo_decorator(n): if n == 0: return 0 if n == 1: return 1 return fib_memo_decorator(n - 1) + fib_memo_decorator(n - 2)## fib_memo_decorator(30) time elapsed: 4.57430000000425e-053. 思考题的研究先说结论: memorize(fib)不能起到记忆效果！！！很多人可能觉得“你这写的都是啥玩意儿阿，一会儿自由变量一会儿lambda一会儿decorator的，传lambda和定义好的函数由啥区别啊,为什么定义好的函数不能直接传入memorize而要用decorator啊。”，别急，我们慢慢来。（以下内容可能有误，有大佬发现烦请指出)先画出memorize求值的环境模型。要区分fib_memo_lambda，decorator和fib_memo = memorize(fib),只需要将实际参数应用于上面这个环境模型中即可。3.1 fib_memo_lambda的求值过程def memorize(f): memo = {} def inner(n): if n not in memo: memo[n] = f(n) return memo[n] return inner fib_memo_lambda = memorize(lambda x: 0 if x == 0 else 1 if x == 1 else fib_memo_lambda(x - 1) + fib_memo_lambda(x - 2))fib_memo_lambda绑定的环境如下图所示:从这里可以看出fib_memo_lambda绑定环境中的f其实是一个unnamed lambda,该unnamed lambda运算时会去递归的调用有记忆的fib_memo_lambda，该递归调用开销不大，因为我递归调用的是带记忆的过程。3.2 fib_memo_lambda = memorize(fib)无效的原因先上图，fib_memo_lambda=memorize(fib)的环境模型如下。可以看到memorize(fib)这里的unnamed lambda递归调用的其实是不带记忆的过程fib,那么memorize(fib)每次计算一个不在memo中的值的时候，就会进入到无记忆的fib当中去求值，其速度自然也就慢了。3.3 fib_memo_decorator有效的原因先看装饰器的定义： 装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价: def f(...): ...f = staticmethod(f)@staticmethoddef f(...): ... PEP对decorator的解释也就是说,以下两个语句完全等价@memorizedef fib_memo_decorator(n):fib_memo_decorator = memorize(fib_memo_decorator)这个过程中fib_memo_decorator发生了重新绑定。fib_memo_decorator在加装饰器前的样子：容易看出就是个普通的递归过程。执行fib_memo_decorator=memorize(fib_memo_decorator):虚线为fib_memo_decorator发生的第二次绑定。可以看出发生二次绑定后，inner内的f递归调用的也是带记忆的过程了。4. 总结懒得总结了，应该讲的很清楚了_(´ཀ`」 ∠)_。" } ]
