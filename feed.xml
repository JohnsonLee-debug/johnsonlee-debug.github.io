<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://johnsonlee.github.io/</id><title>JohnsonLee's Blog</title><subtitle>Just a stupid blog.</subtitle> <updated>2022-04-11T19:05:52+08:00</updated> <author> <name>Johnsonlee</name> <uri>https://johnsonlee.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://johnsonlee.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://johnsonlee.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Johnsonlee </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>泛型在Go中的应用</title><link href="https://johnsonlee.github.io/posts/go-generics/" rel="alternate" type="text/html" title="泛型在Go中的应用" /><published>2022-03-22T20:08:00+08:00</published> <updated>2022-03-22T20:08:00+08:00</updated> <id>https://johnsonlee.github.io/posts/go-generics/</id> <content src="https://johnsonlee.github.io/posts/go-generics/" /> <author> <name>Johnsonlee</name> </author> <category term="Go" /> <summary> Go1.18正式发布，从此Go算是正式有了泛型，本文来探讨Go泛型的几种应用场景。 类型安全的函数式接口 在Go语言里，函数是一等公民，这意味着你可以进行一定程度的函数式编程，但是因为Go拉胯的类型系统以及Lambda表达式的缺位，Go做起函数式编程来总是不太舒服，现在有了参数化类型以后map，fold，filter等函数总算是能舒服些了。接下来看看如何利用泛型实现出类型安全的Map， Filter， Foldl，Foldr。 实现 从这几个函数的类型签名入手，然后按语义进行翻译就是了： 这里类型签名采用我偏爱的Haskell的类型签名（同时混合使用了Go的类型），个人认为这种记法的好处在于分离了identifier和type signature，便于一眼看出函数的类型以及进行类型的运算；这种记法里的-&amp;gt;可以理解为一个映射 Map :: (A -&amp;gt;... </summary> </entry> <entry><title>词法分析之NFA, DFA, Min-DFA与RE, RG</title><link href="https://johnsonlee.github.io/posts/FSA_and_RE/" rel="alternate" type="text/html" title="词法分析之NFA, DFA, Min-DFA与RE, RG" /><published>2022-03-02T23:52:00+08:00</published> <updated>2022-03-02T23:52:00+08:00</updated> <id>https://johnsonlee.github.io/posts/FSA_and_RE/</id> <content src="https://johnsonlee.github.io/posts/FSA_and_RE/" /> <author> <name>Johnsonlee</name> </author> <category term="编译原理" /> <category term="词法分析" /> <summary> Computation with automata. Glossary NFA: Non-Deterministic Finite Automata 非确定性的有限状态自动机 对于NFA的非确定, 有两种有趣的解释 在需要做出不确定选择的时候, NFA会复制自己并执行所有的操作, 如果最终有任何一台自动机到达了接收状态, 那么NFA接收这个输入 在需要做出不确定选择的时候, NFA的选择总是正确, 也就是说, 只要这个串是能被接收的, 那NFA一定能选对 DFA: Deterministic Finite Automata 确定性的有限状态自动机 Min-DFA: Minimal Deterministic Finite Aut... </summary> </entry> <entry><title>常用网站分类收藏</title><link href="https://johnsonlee.github.io/posts/website_archive/" rel="alternate" type="text/html" title="常用网站分类收藏" /><published>2022-02-26T00:00:00+08:00</published> <updated>2022-02-26T00:00:00+08:00</updated> <id>https://johnsonlee.github.io/posts/website_archive/</id> <content src="https://johnsonlee.github.io/posts/website_archive/" /> <author> <name>Johnsonlee</name> </author> <category term="网站分类收藏" /> <summary> Frequently use website 资源类 Google Scholar IEEE Xplore ACM Digital Library IACR’s ePrint archive DBLP arXiv CiteSeerX JSTOR SpringerLink Semantic Scholar Libgen SciHub 大牛博客 包云岗的博客 美团技术团队 Keep Coding Tech Explorer, 数据库, LinuxC 凝神长老 阮一峰 JR’s Blog Mthli JYY的WIKI 玄简君 Kaito, 中间件, 分布式系统的讲解非常不错 Go语言 Go设计模式与Web开发等 Go Wiki Go语言高性能编程 菜... </summary> </entry> <entry><title>通用的Memorization方法</title><link href="https://johnsonlee.github.io/posts/memorize/" rel="alternate" type="text/html" title="通用的Memorization方法" /><published>2021-04-23T16:58:00+08:00</published> <updated>2021-04-23T16:58:00+08:00</updated> <id>https://johnsonlee.github.io/posts/memorize/</id> <content src="https://johnsonlee.github.io/posts/memorize/" /> <author> <name>Johnsonlee</name> </author> <category term="SICP" /> <summary> 最近看到了一个scheme实现的通用记忆化方法，但其代码晦涩难懂，整理了一份python版本，发现远比lisp简单明了，遂写一篇博客保留之。 1. Intro 记忆法(Memorization)，或称表格法(tabulation)是一种常用的缓存技术，采用这种技术的函数将前面已经算出的一些值记录在一个局部的字典里，这种手段能够大大加快一些函数的效率。采用记忆法的过程维护着一个字典，其中保存着前面已经做过的调用求出的值，以产生这些值的对应参数作为Key。当这种过程被调用时，它首先检查有关的字典，看看相应的值是否已经在那里，如果找到了，就直接返回这个值; 否则就以正常的方式计算出相应的值，并将这个值保存到表格里。 举一个经典的例子: memo = {0: 0, 1: 1} # 不带记忆的版本 def fib(n): if n == 0: ret... </summary> </entry> </feed>
